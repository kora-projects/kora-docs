---
title: File Upload & Storage with S3
summary: Learn how to handle file uploads and store data in S3-compatible storage using Kora's MinIO client, extending the HTTP server guide with cloud storage capabilities
tags: s3, minio, file-upload, cloud-storage, multipart, object-storage
---

# File Upload & Storage with S3

This comprehensive guide demonstrates how to build production-ready file upload and storage capabilities using Kora's MinIO S3 client. You'll learn to handle multipart form data, store files in object storage, and build a complete file management system that extends the HTTP server guide's form handling capabilities.

## What is Object Storage?

**Object storage** represents a fundamental shift from traditional file systems and block storage:

- **Flat Namespace**: Unlike hierarchical file systems, object storage uses a flat structure where every object is identified by a unique key
- **Metadata-Rich**: Each object can store extensive metadata alongside the actual data
- **HTTP-Based**: Objects are accessed via standard HTTP methods (GET, PUT, DELETE)
- **Massively Scalable**: Designed to handle billions of objects across distributed systems
- **Eventual Consistency**: Optimized for high availability over strict consistency

## S3 Standard

**Amazon Simple Storage Service (S3)**, launched in 2006, established the de facto standard for object storage:

- **Global Infrastructure**: S3's reliability and global reach set the benchmark for cloud storage
- **S3 API Standard**: Became the industry standard that all major cloud providers implement
- **Ecosystem Impact**: Spawned an entire ecosystem of tools, libraries, and services

## Why Object Storage for Modern Applications?

**Scalability Challenges Solved:**
- Traditional file systems struggle with millions of files in a single directory
- Object storage handles billions of objects effortlessly
- Distributed architecture provides unlimited horizontal scaling

**Developer Experience:**
- Simple HTTP-based API eliminates complex file system operations
- Consistent interface across development, staging, and production
- Rich metadata support enables advanced querying and organization

**Operational Benefits:**
- Built-in replication and data protection
- Global content delivery through CDN integration
- Comprehensive audit logging and access controls
- Cost optimization through intelligent tiering

**Modern Application Patterns:**
- **User-Generated Content**: Profile pictures, documents, media files
- **Data Lakes**: Centralized storage for analytics and machine learning
- **Backup & Archive**: Long-term retention with automated lifecycle policies
- **Static Asset Delivery**: High-performance content delivery for web applications

## What You'll Build

You'll create a sophisticated file management system that includes:

- **Advanced File Upload API**: Multipart form processing with validation, streaming support, and error handling
- **S3 Object Storage Integration**: Seamless integration with MinIO (S3-compatible storage) for scalable file storage
- **Complete File Lifecycle Management**: Upload, download, list, and delete operations with metadata tracking
- **Production-Ready Architecture**: Proper error handling, logging, metrics, and comprehensive testing
- **Local Development Environment**: MinIO Docker setup for zero-cost development and testing

## What You'll Need

- JDK 17 or later
- Gradle 7.0+
- Docker (for local MinIO setup)
- A text editor or IDE
- Completed [HTTP Server Guide](../http-server.md) guide

## Prerequisites

!!! note "Required: Complete HTTP Server Guide"

    This guide assumes you have completed the **[HTTP Server Guide](../http-server.md)** and have a working Kora project with form handling capabilities.

    If you haven't completed the HTTP server guide yet, please do so first as this guide builds upon those concepts.

## Add Dependencies

Add the MinIO S3 client dependency to your existing Kora project:

===! ":fontawesome-brands-java: `Java`"

    ```gradle title="build.gradle"
    dependencies {
        // ... existing dependencies ...

        implementation("ru.tinkoff.kora.experimental:s3-client-minio")
    }
    ```

===! ":simple-kotlin: `Kotlin`"

    ```kotlin title="build.gradle.kts"
    dependencies {
        // ... existing dependencies ...

        implementation("ru.tinkoff.kora.experimental:s3-client-minio")
    }
    ```

## Add Modules

Update your Application interface to include the MinIO S3 client module:

===! ":fontawesome-brands-java: `Java`"

    `src/main/java/ru/tinkoff/kora/example/Application.java`:

    ```java
    package ru.tinkoff.kora.example;

    import ru.tinkoff.kora.common.KoraApp;
    import ru.tinkoff.kora.http.server.undertow.UndertowHttpServerModule;
    import ru.tinkoff.kora.json.module.JsonModule;
    import ru.tinkoff.kora.logging.logback.LogbackModule;
    import ru.tinkoff.kora.s3.client.minio.MinioS3ClientModule;

    @KoraApp
    public interface Application extends
            UndertowHttpServerModule,
            JsonModule,
            LogbackModule,
            MinioS3ClientModule {

    }
    ```

=== ":simple-kotlin: `Kotlin`"

    `src/main/kotlin/ru/tinkoff/kora/example/Application.kt`:

    ```kotlin
    package ru.tinkoff.kora.example

    import ru.tinkoff.kora.common.KoraApp
    import ru.tinkoff.kora.http.server.undertow.UndertowHttpServerModule
    import ru.tinkoff.kora.json.module.JsonModule
    import ru.tinkoff.kora.logging.logback.LogbackModule
    import ru.tinkoff.kora.s3.client.minio.MinioS3ClientModule

    @KoraApp
    interface Application :
        UndertowHttpServerModule,
        JsonModule,
        LogbackModule,
        MinioS3ClientModule {

    }
    ```

## Understanding S3-Compatible Storage

**What is MinIO?**
MinIO is an S3-compatible object storage server that you can run locally for development and testing. It provides the same API as AWS S3, allowing you to develop against local storage and deploy to any S3-compatible service (AWS S3, Google Cloud Storage, etc.).

**Why Use Object Storage?**
- **Scalability**: Handle large files and high throughput
- **Durability**: Built-in replication and data protection
- **Cost-Effective**: Pay only for what you store and access
- **Integration**: Works with CDNs, backup systems, and analytics tools

**Key Concepts:**
- **Buckets**: Containers for storing objects (like directories)
- **Objects**: Files stored in buckets with unique keys
- **Keys**: Unique identifiers for objects within a bucket
- **Metadata**: Additional information stored with objects

## Set Up Local MinIO

For development and testing, you'll run MinIO locally using Docker. This gives you a fully functional S3-compatible storage without cloud costs.

Create `docker-compose.yml` in your project root:

```yaml
version: '3.8'
services:
  minio:
    image: minio/minio:latest
    ports:
      - "9000:9000"          # MinIO API
      - "9001:9001"          # MinIO Console (Web UI)
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
    volumes:
      - minio_data:/data
    command: server /data --console-address ":9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3

volumes:
  minio_data:
```

Start MinIO:

```bash
docker-compose up -d
```

**Access Points:**
- **MinIO API**: http://localhost:9000
- **MinIO Console**: http://localhost:9001 (login: minioadmin / minioadmin)

!!! tip "MinIO Console"

    Use the MinIO Console to create buckets, upload files manually, and inspect your storage setup. This is helpful for debugging and understanding your data structure.

## Configure S3 Client

Configure the MinIO client to connect to your local MinIO instance:

Create `src/main/resources/application.conf`:

```hocon
httpServer {
  publicApiHttpPort = 8080
}

s3client {
  url = "http://localhost:9000"
  accessKey = "minioadmin"
  secretKey = "minioadmin"

  telemetry {
    logging.enabled = true
    metrics.enabled = true
    tracing.enabled = true
  }
}
```

**Configuration Options:**
- **url**: MinIO server endpoint
- **accessKey/secretKey**: Credentials (configured in docker-compose)
- **telemetry**: Enable logging, metrics, and tracing for S3 operations

## Create S3 Storage Service

Now we'll create the core service that handles all S3 file operations. This service acts as the bridge between your HTTP controllers and the MinIO S3 client, providing a clean, testable API for file management.

The `S3FileService` provides a complete file management API:

**File Organization**:
- Files are stored with unique IDs to prevent conflicts
- Organized in a `files/{fileId}/{filename}` structure for easy retrieval
- Metadata tracked for each file (size, content type, etc.)

**Bucket Management**:
- Automatic bucket creation on service initialization
- Configurable bucket name for different environments

**CRUD Operations**:
- **Create**: Upload files with streaming support
- **Read**: Download files by ID and filename
- **List**: Browse all uploaded files with metadata
- **Delete**: Remove files from storage

### Learning Path: From Imperative to Declarative

This section demonstrates the **imperative approach** using direct MinIO client calls. While functional, we'll refactor this to use Kora's declarative S3 client in the next section for cleaner, more maintainable code.

The imperative approach gives you full control over S3 operations and is useful when you need:
- Complex business logic
- Custom error handling
- Fine-grained control over requests
- Integration with other services

### Implementation

Create a service that handles file operations using the injected MinioClient:

===! ":fontawesome-brands-java: `Java`"

    Create `src/main/java/ru/tinkoff/kora/example/service/S3FileService.java`:

    ```java
    package ru.tinkoff.kora.example.service;

    import io.minio.*;
    import io.minio.messages.Item;
    import ru.tinkoff.kora.common.Component;
    import ru.tinkoff.kora.common.Lifecycle;
    import ru.tinkoff.kora.example.dto.FileMetadata;

    import java.io.InputStream;
    import java.util.ArrayList;
    import java.util.List;
    import java.util.UUID;

    @Component
    public final class S3FileService implements Lifecycle {

        private static final String BUCKET_NAME = "uploads";
        private final MinioClient minioClient;

        public S3FileService(MinioClient minioClient) {
            this.minioClient = minioClient;
        }

        @Override
        public void init() throws Exception {
            try {
                boolean bucketExists = minioClient.bucketExists(
                    BucketExistsArgs.builder()
                        .bucket(BUCKET_NAME)
                        .build()
                );

                if (!bucketExists) {
                    minioClient.makeBucket(
                        MakeBucketArgs.builder()
                            .bucket(BUCKET_NAME)
                            .build()
                    );
                }
            } catch (Exception e) {
                throw new RuntimeException("Failed to create bucket", e);
            }
        }

        @Override
        public void release() throws Exception {
            // Cleanup resources if needed
        }

        public FileMetadata uploadFile(String originalFilename, InputStream inputStream, long size, String contentType) {
            try {
                String fileId = UUID.randomUUID().toString();
                String key = "files/" + fileId + "/" + originalFilename;

                minioClient.putObject(
                    PutObjectArgs.builder()
                        .bucket(BUCKET_NAME)
                        .object(key)
                        .stream(inputStream, size, -1)
                        .contentType(contentType)
                        .build()
                );

                return new FileMetadata(fileId, originalFilename, size, contentType, key);

            } catch (Exception e) {
                throw new RuntimeException("Failed to upload file", e);
            }
        }

        public InputStream downloadFile(String fileId, String filename) {
            try {
                String key = "files/" + fileId + "/" + filename;
                return minioClient.getObject(
                    GetObjectArgs.builder()
                        .bucket(BUCKET_NAME)
                        .object(key)
                        .build()
                );

            } catch (Exception e) {
                throw new RuntimeException("Failed to download file", e);
            }
        }

        public List<FileMetadata> listFiles() {
            try {
                List<FileMetadata> files = new ArrayList<>();
                Iterable<Result<Item>> results = minioClient.listObjects(
                    ListObjectsArgs.builder()
                        .bucket(BUCKET_NAME)
                        .prefix("files/")
                        .build()
                );

                for (Result<Item> result : results) {
                    Item item = result.get();
                    String key = item.objectName();
                    String[] parts = key.split("/");
                    if (parts.length >= 3) {
                        String fileId = parts[1];
                        String filename = parts[2];
                        files.add(new FileMetadata(
                            fileId,
                            filename,
                            item.size(),
                            item.contentType(),
                            key
                        ));
                    }
                }

                return files;

            } catch (Exception e) {
                throw new RuntimeException("Failed to list files", e);
            }
        }

        public void deleteFile(String fileId, String filename) {
            try {
                String key = "files/" + fileId + "/" + filename;
                minioClient.removeObject(
                    RemoveObjectArgs.builder()
                        .bucket(BUCKET_NAME)
                        .object(key)
                        .build()
                );

            } catch (Exception e) {
                throw new RuntimeException("Failed to delete file", e);
            }
        }
    }
    ```

=== ":simple-kotlin: `Kotlin`"

    Create `src/main/kotlin/ru/tinkoff/kora/example/service/S3FileService.kt`:

    ```kotlin
    package ru.tinkoff.kora.example.service

    import io.minio.*
    import io.minio.messages.Item
    import ru.tinkoff.kora.common.Component
    import ru.tinkoff.kora.common.Lifecycle
    import ru.tinkoff.kora.example.dto.FileMetadata
    import java.io.InputStream
    import java.util.*

    @Component
    class S3FileService(
        private val minioClient: MinioClient
    ) : Lifecycle {

        private companion object {
            const val BUCKET_NAME = "uploads"
        }

        override fun init() {
            try {
                val bucketExists = minioClient.bucketExists(
                    BucketExistsArgs.builder()
                        .bucket(BUCKET_NAME)
                        .build()
                )

                if (!bucketExists) {
                    minioClient.makeBucket(
                        MakeBucketArgs.builder()
                            .bucket(BUCKET_NAME)
                            .build()
                    )
                }
            } catch (e: Exception) {
                throw RuntimeException("Failed to create bucket", e)
            }
        }

        override fun release() {
            // Cleanup resources if needed
        }

        fun uploadFile(originalFilename: String, inputStream: InputStream, size: Long, contentType: String): FileMetadata {
            try {
                val fileId = UUID.randomUUID().toString()
                val key = "files/$fileId/$originalFilename"

                minioClient.putObject(
                    PutObjectArgs.builder()
                        .bucket(BUCKET_NAME)
                        .object(key)
                        .stream(inputStream, size, -1)
                        .contentType(contentType)
                        .build()
                )

                return FileMetadata(fileId, originalFilename, size, contentType, key)

            } catch (e: Exception) {
                throw RuntimeException("Failed to upload file", e)
            }
        }

        fun downloadFile(fileId: String, filename: String): InputStream {
            try {
                val key = "files/$fileId/$filename"
                return minioClient.getObject(
                    GetObjectArgs.builder()
                        .bucket(BUCKET_NAME)
                        .object(key)
                        .build()
                )

            } catch (e: Exception) {
                throw RuntimeException("Failed to download file", e)
            }
        }

        fun listFiles(): List<FileMetadata> {
            try {
                val files = mutableListOf<FileMetadata>()
                val results = minioClient.listObjects(
                    ListObjectsArgs.builder()
                        .bucket(BUCKET_NAME)
                        .prefix("files/")
                        .build()
                )

                for (result in results) {
                    val item = result.get()
                    val key = item.objectName()
                    val parts = key.split("/")
                    if (parts.size >= 3) {
                        val fileId = parts[1]
                        val filename = parts[2]
                        files.add(FileMetadata(
                            fileId,
                            filename,
                            item.size(),
                            item.contentType(),
                            key
                        ))
                    }
                }

                return files

            } catch (e: Exception) {
                throw RuntimeException("Failed to list files", e)
            }
        }

        fun deleteFile(fileId: String, filename: String) {
            try {
                val key = "files/$fileId/$filename"
                minioClient.removeObject(
                    RemoveObjectArgs.builder()
                        .bucket(BUCKET_NAME)
                        .object(key)
                        .build()
                )

            } catch (e: Exception) {
                throw RuntimeException("Failed to delete file", e)
            }
        }
    }
    ```

## Create File Metadata DTO

Create the data transfer object for file information:

===! ":fontawesome-brands-java: `Java`"

    Create `src/main/java/ru/tinkoff/kora/example/dto/FileMetadata.java`:

    ```java
    package ru.tinkoff.kora.example.dto;

    import ru.tinkoff.kora.json.common.annotation.Json;

    @Json
    public record FileMetadata(
        String id,
        String filename,
        long size,
        String contentType,
        String key
    ) {}
    ```

=== ":simple-kotlin: `Kotlin`"

    Create `src/main/kotlin/ru/tinkoff/kora/example/dto/FileMetadata.kt`:

    ```kotlin
    package ru.tinkoff.kora.example.dto

    import ru.tinkoff.kora.json.common.annotation.Json

    @Json
    data class FileMetadata(
        val id: String,
        val filename: String,
        val size: Long,
        val contentType: String,
        val key: String
    )
    ```

## Refactoring to Declarative S3 Client

Now let's refactor our implementation to use Kora's declarative S3 client. This approach provides type safety, reduces boilerplate code, and offers a more elegant API for simple CRUD operations.

### Why Refactor to Declarative?

**Benefits of Declarative Clients:**
- **Type Safety**: Compile-time guarantees for method signatures
- **Less Boilerplate**: No need to manually construct request objects
- **Automatic Mapping**: Request/response objects are handled automatically
- **Cleaner Code**: Focus on business logic, not S3 API details

### Replacing the Service with Declarative Client

Instead of manually using the MinIO client, we'll use Kora's declarative S3 client that generates the implementation automatically. This eliminates the need for our custom `S3FileService` and provides a cleaner, more maintainable solution.

Create the declarative S3 client:

===! ":fontawesome-brands-java: `Java`"

    Create `src/main/java/ru/tinkoff/kora/example/client/S3FileClient.java`:

    ```java
    package ru.tinkoff.kora.example.client;

    import ru.tinkoff.kora.s3.client.annotation.S3;
    import ru.tinkoff.kora.s3.client.model.S3Object;
    import ru.tinkoff.kora.s3.client.model.S3ObjectList;
    import ru.tinkoff.kora.s3.client.model.S3ObjectMeta;
    import ru.tinkoff.kora.s3.client.model.S3Body;

    @S3.Client("uploads")
    public interface S3FileClient {

        @S3.Put("files/{fileId}/{filename}")
        S3Object uploadFile(String fileId, String filename, S3Body body);

        @S3.Get("files/{fileId}/{filename}")
        S3Object downloadFile(String fileId, String filename);

        @S3.List("files/")
        S3ObjectList listFiles();

        @S3.Delete("files/{fileId}/{filename}")
        void deleteFile(String fileId, String filename);
    }
    ```

=== ":simple-kotlin: `Kotlin`"

    Create `src/main/kotlin/ru/tinkoff/kora/example/client/S3FileClient.kt`:

    ```kotlin
    package ru.tinkoff.kora.example.client

    import ru.tinkoff.kora.s3.client.annotation.S3
    import ru.tinkoff.kora.s3.client.model.*

    @S3.Client("uploads")
    interface S3FileClient {

        @S3.Put("files/{fileId}/{filename}")
        fun uploadFile(fileId: String, filename: String, body: S3Body): S3Object

        @S3.Get("files/{fileId}/{filename}")
        fun downloadFile(fileId: String, filename: String): S3Object

        @S3.List("files/")
        fun listFiles(): S3ObjectList

        @S3.Delete("files/{fileId}/{filename}")
        fun deleteFile(fileId: String, filename: String)
    }
    ```

!!! note "Refactored Implementation"

    We've refactored from the imperative `S3FileService` to the declarative `S3FileClient` for cleaner, more maintainable code. The declarative approach provides:

    - **Type Safety**: Compile-time guarantees for method signatures
    - **Less Boilerplate**: Automatic request/response handling
    - **Cleaner Code**: Focus on business logic, not S3 API details

    The controller now uses `S3FileClient` directly, eliminating the need for a custom service layer for simple CRUD operations.

## Extend Data Controller for File Uploads

Extend the existing `DataController` from the HTTP server guide to add file upload endpoints:

===! ":fontawesome-brands-java: `Java`"

    Update `src/main/java/ru/tinkoff/kora/example/controller/DataController.java`:

    ```java
    package ru.tinkoff.kora.example.controller;

    import ru.tinkoff.kora.common.Component;
    import ru.tinkoff.kora.http.common.HttpMethod;
    import ru.tinkoff.kora.http.common.annotation.HttpController;
    import ru.tinkoff.kora.http.common.annotation.HttpRoute;
    import ru.tinkoff.kora.http.common.form.FormMultipart;
    import ru.tinkoff.kora.http.common.form.FormUrlEncoded;
    import ru.tinkoff.kora.json.common.annotation.Json;
    import ru.tinkoff.kora.example.dto.FileMetadata;
    import ru.tinkoff.kora.example.client.S3FileClient;
    import ru.tinkoff.kora.s3.client.model.S3Body;

    import java.io.InputStream;
    import java.util.List;
    import java.util.UUID;

    import java.io.InputStream;
    import java.util.List;

    @Component
    @HttpController
    public final class DataController {

        private final S3FileClient s3FileClient;

        public DataController(S3FileClient s3FileClient) {
            this.s3FileClient = s3FileClient;
        }

        // ... existing code from HTTP server guide ...

        // Multipart file upload
        @HttpRoute(method = HttpMethod.POST, path = "/files/upload")
        @Json
        public FileMetadata uploadFile(FormMultipart multipart) {
            FormMultipart.FormPart filePart = multipart.getFirstPart("file")
                .orElseThrow(() -> new IllegalArgumentException("No file provided"));

            String filename = filePart.getFilename()
                .orElseThrow(() -> new IllegalArgumentException("No filename provided"));

            try (InputStream inputStream = filePart.getContent()) {
                String fileId = UUID.randomUUID().toString();
                long size = filePart.getSize();
                String contentType = filePart.getContentType().orElse("application/octet-stream");

                S3Body body = S3Body.fromInputStream(inputStream, size, contentType);
                var s3Object = s3FileClient.uploadFile(fileId, filename, body);

                return new FileMetadata(fileId, filename, size, contentType, "files/" + fileId + "/" + filename);

            } catch (Exception e) {
                throw new RuntimeException("Failed to process file upload", e);
            }
        }

        // List uploaded files
        @HttpRoute(method = HttpMethod.GET, path = "/files")
        @Json
        public List<FileMetadata> listFiles() {
            var s3ObjectList = s3FileClient.listFiles();
            return s3ObjectList.objects().stream()
                .map(s3Object -> {
                    String key = s3Object.key();
                    String[] parts = key.split("/");
                    if (parts.length >= 3) {
                        String fileId = parts[1];
                        String filename = parts[2];
                        return new FileMetadata(
                            fileId,
                            filename,
                            s3Object.size(),
                            s3Object.contentType(),
                            key
                        );
                    }
                    return null;
                })
                .filter(java.util.Objects::nonNull)
                .toList();
        }

        // Download file
        @HttpRoute(method = HttpMethod.GET, path = "/files/{fileId}/{filename}")
        public InputStream downloadFile(String fileId, String filename) {
            var s3Object = s3FileClient.downloadFile(fileId, filename);
            return s3Object.body().inputStream();
        }

        // Delete file
        @HttpRoute(method = HttpMethod.DELETE, path = "/files/{fileId}/{filename}")
        @Json
        public DeleteResponse deleteFile(String fileId, String filename) {
            s3FileClient.deleteFile(fileId, filename);
            return new DeleteResponse("File deleted successfully");
        }

        // ... existing records from HTTP server guide ...

        @Json
        public record DeleteResponse(String message) {}
    }
    ```

=== ":simple-kotlin: `Kotlin`"

    Update `src/main/kotlin/ru/tinkoff/kora/example/controller/DataController.kt`:

    ```kotlin
    package ru.tinkoff.kora.example.controller

    import ru.tinkoff.kora.common.Component
    import ru.tinkoff.kora.http.common.HttpMethod
    import ru.tinkoff.kora.http.common.annotation.*
    import ru.tinkoff.kora.http.common.form.FormMultipart
    import ru.tinkoff.kora.http.common.form.FormUrlEncoded
    import ru.tinkoff.kora.json.common.annotation.Json
    import ru.tinkoff.kora.example.dto.FileMetadata
    import ru.tinkoff.kora.example.client.S3FileClient
    import ru.tinkoff.kora.s3.client.model.S3Body
    import java.io.InputStream
    import java.util.*
    import java.io.InputStream

    @Component
    @HttpController
    class DataController(
        private val s3FileClient: S3FileClient
    ) {

        // ... existing code from HTTP server guide ...

        // Multipart file upload
        @HttpRoute(method = HttpMethod.POST, path = "/files/upload")
        @Json
        fun uploadFile(multipart: FormMultipart): FileMetadata {
            val filePart = multipart.getFirstPart("file")
                .orElseThrow { IllegalArgumentException("No file provided") }

            val filename = filePart.filename
                .orElseThrow { IllegalArgumentException("No filename provided") }

            filePart.content.use { inputStream ->
                val fileId = UUID.randomUUID().toString()
                val size = filePart.size
                val contentType = filePart.contentType.orElse("application/octet-stream")

                val body = S3Body.fromInputStream(inputStream, size, contentType)
                val s3Object = s3FileClient.uploadFile(fileId, filename, body)

                return FileMetadata(fileId, filename, size, contentType, "files/$fileId/$filename")
            }
        }

        // List uploaded files
        @HttpRoute(method = HttpMethod.GET, path = "/files")
        @Json
        fun listFiles(): List<FileMetadata> {
            val s3ObjectList = s3FileClient.listFiles()
            return s3ObjectList.objects().mapNotNull { s3Object ->
                val key = s3Object.key()
                val parts = key.split("/")
                if (parts.size >= 3) {
                    val fileId = parts[1]
                    val filename = parts[2]
                    FileMetadata(
                        fileId,
                        filename,
                        s3Object.size(),
                        s3Object.contentType(),
                        key
                    )
                } else null
            }
        }

        // Download file
        @HttpRoute(method = HttpMethod.GET, path = "/files/{fileId}/{filename}")
        fun downloadFile(fileId: String, filename: String): InputStream {
            val s3Object = s3FileClient.downloadFile(fileId, filename)
            return s3Object.body().inputStream()
        }

        // Delete file
        @HttpRoute(method = HttpMethod.DELETE, path = "/files/{fileId}/{filename}")
        @Json
        fun deleteFile(fileId: String, filename: String): DeleteResponse {
            s3FileClient.deleteFile(fileId, filename)
            return DeleteResponse("File deleted successfully")
        }

        // ... existing data classes from HTTP server guide ...
    }

    @Json
    data class DeleteResponse(val message: String)
    ```

### Exception Handling in Declarative Clients

Kora's declarative S3 client provides clear, specific exceptions for different error scenarios:

**S3-Specific Exceptions:**
- **`S3NotFoundException`** - Thrown when a file cannot be found by the specified key
- **`S3DeleteException`** - Thrown when there's an error deleting a file
- **`S3Exception`** - Thrown for any other S3 operation errors

**Exception Handling Best Practices:**
- **Handle Not Found Cases**: Use `S3NotFoundException` to provide user-friendly "file not found" messages
- **Log Delete Errors**: `S3DeleteException` often indicates permission or connectivity issues
- **Generic Error Handling**: `S3Exception` covers network issues, authentication problems, and other S3 errors

===! ":fontawesome-brands-java: `Java`"

    ```java
    @HttpRoute(method = HttpMethod.GET, path = "/files/{fileId}/{filename}")
    public InputStream downloadFile(String fileId, String filename) {
        try {
            var s3Object = s3FileClient.downloadFile(fileId, filename);
            return s3Object.body().inputStream();
        } catch (S3NotFoundException e) {
            throw new ResponseException(HttpStatus.NOT_FOUND, "File not found");
        } catch (S3Exception e) {
            throw new ResponseException(HttpStatus.INTERNAL_SERVER_ERROR, "Failed to download file");
        }
    }
    ```

=== ":simple-kotlin: `Kotlin`"

    ```kotlin
    @HttpRoute(method = HttpMethod.GET, path = "/files/{fileId}/{filename}")
    fun downloadFile(fileId: String, filename: String): InputStream {
        return try {
            val s3Object = s3FileClient.downloadFile(fileId, filename)
            s3Object.body().inputStream()
        } catch (e: S3NotFoundException) {
            throw ResponseException(HttpStatus.NOT_FOUND, "File not found")
        } catch (e: S3Exception) {
            throw ResponseException(HttpStatus.INTERNAL_SERVER_ERROR, "Failed to download file")
        }
    }
    ```

## Test File Upload API

Build and run your application:

```bash
./gradlew build
./gradlew run
```

Test the file upload functionality:

```bash
# Upload a file
curl -X POST http://localhost:8080/files/upload \
  -F "file=@/path/to/your/file.jpg"

# List uploaded files
curl http://localhost:8080/files

# Download a file (replace with actual fileId and filename)
curl http://localhost:8080/files/123/file.jpg -o downloaded_file.jpg

# Delete a file (replace with actual fileId and filename)
curl -X DELETE http://localhost:8080/files/123/file.jpg
```

You should see:
- **Successful uploads** with file metadata returned
- **File listings** showing all uploaded files
- **File downloads** working correctly
- **File deletions** removing files from storage

## Testing File Upload Functionality

Kora provides excellent testing support with Testcontainers for integration testing. Add the following test dependencies:

===! ":fontawesome-brands-java: `Java`"

    ```gradle title="build.gradle"
    dependencies {
        // ... existing dependencies ...

        testImplementation("ru.tinkoff.kora:json-module")
        testImplementation("ru.tinkoff.kora:junit5-module")
        testImplementation("org.testcontainers:minio:1.19.3")
        testImplementation("org.testcontainers:junit-jupiter:1.19.3")
    }
    ```

===! ":simple-kotlin: `Kotlin`"

    ```kotlin title="build.gradle.kts"
    dependencies {
        // ... existing dependencies ...

        testImplementation("ru.tinkoff.kora:json-module")
        testImplementation("ru.tinkoff.kora:junit5-module")
        testImplementation("org.testcontainers:minio:1.19.3")
        testImplementation("org.testcontainers:junit-jupiter:1.19.3")
    }
    ```

Create a test configuration for testing with MinIO:

===! ":fontawesome-brands-java: `Java`"

    Create `src/test/java/ru/tinkoff/kora/example/TestApplication.java`:

    ```java
    package ru.tinkoff.kora.example;

    import ru.tinkoff.kora.common.KoraApp;
    import ru.tinkoff.kora.config.hocon.HoconConfigModule;
    import ru.tinkoff.kora.http.client.ok.OkHttpClientModule;
    import ru.tinkoff.kora.http.server.undertow.UndertowHttpServerModule;
    import ru.tinkoff.kora.json.module.JsonModule;
    import ru.tinkoff.kora.logging.logback.LogbackModule;
    import ru.tinkoff.kora.s3.client.minio.MinioS3ClientModule;

    @KoraApp
    public interface TestApplication extends
            HoconConfigModule,
            LogbackModule,
            UndertowHttpServerModule,
            JsonModule,
            MinioS3ClientModule,
            OkHttpClientModule {

    }
    ```

=== ":simple-kotlin: `Kotlin`"

    Create `src/test/kotlin/ru/tinkoff/kora/example/TestApplication.kt`:

    ```kotlin
    package ru.tinkoff.kora.example

    import ru.tinkoff.kora.common.KoraApp
    import ru.tinkoff.kora.config.hocon.HoconConfigModule
    import ru.tinkoff.kora.http.client.ok.OkHttpClientModule
    import ru.tinkoff.kora.http.server.undertow.UndertowHttpServerModule
    import ru.tinkoff.kora.json.module.JsonModule
    import ru.tinkoff.kora.logging.logback.LogbackModule
    import ru.tinkoff.kora.s3.client.minio.MinioS3ClientModule

    @KoraApp
    interface TestApplication :
        HoconConfigModule,
        LogbackModule,
        UndertowHttpServerModule,
        JsonModule,
        MinioS3ClientModule,
        OkHttpClientModule {

    }
    ```

Create a test configuration file:

Create `src/test/resources/application.conf`:

```hocon
httpServer {
  publicApiHttpPort = 0  # Random port for testing
}

s3client {
  url = ${MINIO_URL}
  accessKey = "minioadmin"
  secretKey = "minioadmin"
  region = "us-east-1"
}
```

Create integration tests with MinIO Testcontainers:

===! ":fontawesome-brands-java: `Java`"

    Create `src/test/java/ru/tinkoff/kora/example/S3FileClientTest.java`:

    ```java
    package ru.tinkoff.kora.example;

    import org.junit.jupiter.api.BeforeEach;
    import org.junit.jupiter.api.Test;
    import org.testcontainers.containers.MinIOContainer;
    import org.testcontainers.junit.jupiter.Container;
    import org.testcontainers.junit.jupiter.Testcontainers;
    import ru.tinkoff.kora.example.dto.FileMetadata;
    import ru.tinkoff.kora.example.client.S3FileClient;
    import ru.tinkoff.kora.s3.client.model.S3Body;
    import ru.tinkoff.kora.test.extension.junit5.KoraAppTest;
    import ru.tinkoff.kora.test.extension.junit5.TestComponent;

    import java.io.ByteArrayInputStream;
    import java.nio.charset.StandardCharsets;
    import java.util.List;

    import static org.assertj.core.api.Assertions.assertThat;

    @Testcontainers
    @KoraAppTest(TestApplication.class)
    public class S3FileClientTest {

        @Container
        static MinIOContainer minio = new MinIOContainer("minio/minio:latest")
            .withUserName("minioadmin")
            .withPassword("minioadmin");

        @TestComponent
        S3FileClient s3FileClient;

        @BeforeEach
        void setup() {
            System.setProperty("MINIO_URL", minio.getS3URL());
        }

        @Test
        void shouldUploadAndDownloadFile() {
            // Given
            String content = "Hello, S3!";
            String filename = "test.txt";
            ByteArrayInputStream inputStream = new ByteArrayInputStream(
                content.getBytes(StandardCharsets.UTF_8)
            );

            // When
            String fileId = UUID.randomUUID().toString();
            S3Body body = S3Body.fromInputStream(inputStream, content.length(), "text/plain");
            var s3Object = s3FileClient.uploadFile(fileId, filename, body);

            // Then
            assertThat(s3Object.key()).isEqualTo("files/" + fileId + "/" + filename);
            assertThat(s3Object.size()).isEqualTo(content.length());
            assertThat(s3Object.contentType()).isEqualTo("text/plain");
        }

        @Test
        void shouldListFiles() {
            // Given
            String content = "Test file content";
            ByteArrayInputStream inputStream = new ByteArrayInputStream(
                content.getBytes(StandardCharsets.UTF_8)
            );
            String fileId = UUID.randomUUID().toString();
            S3Body body = S3Body.fromInputStream(inputStream, content.length(), "text/plain");
            s3FileClient.uploadFile(fileId, "file1.txt", body);

            // When
            var s3ObjectList = s3FileClient.listFiles();

            // Then
            assertThat(s3ObjectList.objects()).hasSizeGreaterThanOrEqualTo(1);
            assertThat(s3ObjectList.objects().get(0).key()).contains("file1.txt");
        }

        @Test
        void shouldDeleteFile() {
            // Given
            String content = "File to delete";
            ByteArrayInputStream inputStream = new ByteArrayInputStream(
                content.getBytes(StandardCharsets.UTF_8)
            );
            String fileId = UUID.randomUUID().toString();
            String filename = "delete-me.txt";
            S3Body body = S3Body.fromInputStream(inputStream, content.length(), "text/plain");
            s3FileClient.uploadFile(fileId, filename, body);

            // When
            s3FileClient.deleteFile(fileId, filename);

            // Then - file should be gone from list
            var s3ObjectList = s3FileClient.listFiles();
            assertThat(s3ObjectList.objects()).noneMatch(s3Object -> s3Object.key().contains(fileId));
        }
    }
    ```

=== ":simple-kotlin: `Kotlin`"

    Create `src/test/kotlin/ru/tinkoff/kora/example/S3FileClientTest.kt`:

    ```kotlin
    package ru.tinkoff.kora.example

    import org.junit.jupiter.api.BeforeEach
    import org.junit.jupiter.api.Test
    import org.testcontainers.containers.MinIOContainer
    import org.testcontainers.junit.jupiter.Container
    import org.testcontainers.junit.jupiter.Testcontainers
    import ru.tinkoff.kora.example.dto.FileMetadata
    import ru.tinkoff.kora.example.client.S3FileClient
    import ru.tinkoff.kora.s3.client.model.S3Body
    import ru.tinkoff.kora.test.extension.junit5.KoraAppTest
    import ru.tinkoff.kora.test.extension.junit5.TestComponent
    import java.io.ByteArrayInputStream
    import java.nio.charset.StandardCharsets
    import kotlin.test.assertEquals
    import kotlin.test.assertNotNull
    import kotlin.test.assertTrue

    @Testcontainers
    @KoraAppTest(TestApplication::class)
    class S3FileClientTest {

        @Container
        companion object {
            val minio = MinIOContainer("minio/minio:latest")
                .withUserName("minioadmin")
                .withPassword("minioadmin")
        }

        @TestComponent
        lateinit var s3FileClient: S3FileClient

        @BeforeEach
        fun setup() {
            System.setProperty("MINIO_URL", minio.s3URL)
        }

        @Test
        fun shouldUploadAndDownloadFile() {
            // Given
            val content = "Hello, S3!"
            val filename = "test.txt"
            val inputStream = ByteArrayInputStream(
                content.toByteArray(StandardCharsets.UTF_8)
            )

            // When
            val fileId = UUID.randomUUID().toString()
            val body = S3Body.fromInputStream(inputStream, content.length.toLong(), "text/plain")
            val s3Object = s3FileClient.uploadFile(fileId, filename, body)

            // Then
            assertEquals("files/$fileId/$filename", s3Object.key())
            assertEquals(content.length.toLong(), s3Object.size())
            assertEquals("text/plain", s3Object.contentType())
        }

        @Test
        fun shouldListFiles() {
            // Given
            val content = "Test file content"
            val inputStream = ByteArrayInputStream(
                content.toByteArray(StandardCharsets.UTF_8)
            )
            val fileId = UUID.randomUUID().toString()
            val body = S3Body.fromInputStream(inputStream, content.length.toLong(), "text/plain")
            s3FileClient.uploadFile(fileId, "file1.txt", body)

            // When
            val s3ObjectList = s3FileClient.listFiles()

            // Then
            assertTrue(s3ObjectList.objects().size >= 1)
            assertTrue(s3ObjectList.objects()[0].key().contains("file1.txt"))
        }

        @Test
        fun shouldDeleteFile() {
            // Given
            val content = "File to delete"
            val inputStream = ByteArrayInputStream(
                content.toByteArray(StandardCharsets.UTF_8)
            )
            val fileId = UUID.randomUUID().toString()
            val filename = "delete-me.txt"
            val body = S3Body.fromInputStream(inputStream, content.length.toLong(), "text/plain")
            s3FileClient.uploadFile(fileId, filename, body)

            // When
            s3FileClient.deleteFile(fileId, filename)

            // Then - file should be gone from list
            val s3ObjectList = s3FileClient.listFiles()
            assertTrue(s3ObjectList.objects().none { it.key().contains(fileId) })
        }
    }
    ```

Run the tests:

```bash
./gradlew test
```

!!! tip "Testcontainers Benefits"

    **Testcontainers** provides:
    - **Real MinIO instances** for accurate testing
    - **Isolated environments** per test run
    - **Automatic cleanup** after tests complete
    - **No manual setup** required

!!! note "Integration Testing Best Practices"

    - Use Testcontainers for external dependencies
    - Test both success and failure scenarios
    - Verify data integrity across operations
    - Clean up test data between tests

## Advanced S3 Operations: Presigned Download URLs

While Kora's declarative S3 client handles most common operations beautifully, some advanced S3 features like presigned URLs require imperative approaches. Presigned URLs allow temporary, secure access to S3 objects without requiring AWS credentials, making them perfect for sharing private files.

### Why Presigned URLs?

**Presigned URLs** provide:
- **Temporary Access**: Time-limited access to private S3 objects
- **Secure Sharing**: Share files without making them public
- **Direct Browser Access**: Allow clients to download files directly from S3
- **Reduced Server Load**: Offload file downloads from your application servers

### When Declarative Approaches Fall Short

Not all S3 operations can be handled declaratively because they require:
- **Dynamic Parameters**: Expiration times, custom headers, HTTP methods
- **Complex Business Logic**: Custom access policies, conditional access
- **Advanced Features**: Multipart uploads, batch operations, custom metadata
- **Integration Requirements**: Third-party service integrations

For these cases, you'll need to create services that use the injected MinIO client directly.

### Creating a Presigned URL Service

Create a service that generates presigned download URLs for secure file access:

===! ":fontawesome-brands-java: `Java`"

    Create `src/main/java/ru/tinkoff/kora/example/service/S3PresignedUrlService.java`:

    ```java
    package ru.tinkoff.kora.example.service;

    import io.minio.GetPresignedObjectUrlArgs;
    import io.minio.MinioClient;
    import io.minio.PutObjectArgs;
    import io.minio.http.Method;
    import ru.tinkoff.kora.common.Component;

    import java.util.concurrent.TimeUnit;

    @Component
    public final class S3PresignedUrlService {

        private static final String BUCKET_NAME = "uploads";
        private final MinioClient minioClient;

        public S3PresignedUrlService(MinioClient minioClient) {
            this.minioClient = minioClient;
        }

        /**
         * Generate a presigned URL for downloading a file
         * @param fileId The unique file identifier
         * @param filename The original filename
         * @param expirationMinutes How long the URL should be valid (in minutes)
         * @return Presigned URL for GET requests
         */
        public String generateDownloadUrl(String fileId, String filename, int expirationMinutes) {
            try {
                String key = "files/" + fileId + "/" + filename;
                return minioClient.getPresignedObjectUrl(
                    GetPresignedObjectUrlArgs.builder()
                        .method(Method.GET)
                        .bucket(BUCKET_NAME)
                        .object(key)
                        .expiry(expirationMinutes, TimeUnit.MINUTES)
                        .build()
                );
            } catch (Exception e) {
                throw new RuntimeException("Failed to generate download URL", e);
            }
        }
    }
    ```

=== ":simple-kotlin: `Kotlin`"

    Create `src/main/kotlin/ru/tinkoff/kora/example/service/S3PresignedUrlService.kt`:

    ```kotlin
    package ru.tinkoff.kora.example.service

    import io.minio.GetPresignedObjectUrlArgs
    import io.minio.MinioClient
    import io.minio.http.Method
    import ru.tinkoff.kora.common.Component
    import java.util.concurrent.TimeUnit

    @Component
    class S3PresignedUrlService(
        private val minioClient: MinioClient
    ) {

        companion object {
            private const val BUCKET_NAME = "uploads"
        }

        /**
         * Generate a presigned URL for downloading a file
         * @param fileId The unique file identifier
         * @param filename The original filename
         * @param expirationMinutes How long the URL should be valid (in minutes)
         * @return Presigned URL for GET requests
         */
        fun generateDownloadUrl(fileId: String, filename: String, expirationMinutes: Int): String {
            try {
                val key = "files/$fileId/$filename"
                return minioClient.getPresignedObjectUrl(
                    GetPresignedObjectUrlArgs.builder()
                        .method(Method.GET)
                        .bucket(BUCKET_NAME)
                        .`object`(key)
                        .expiry(expirationMinutes, TimeUnit.MINUTES)
                        .build()
                )
            } catch (e: Exception) {
                throw RuntimeException("Failed to generate download URL", e)
            }
        }
    }
    ```

### Integrating Presigned Download URLs into the Controller

Add a presigned download URL endpoint to your DataController:

===! ":fontawesome-brands-java: `Java`"

    Update `src/main/java/ru/tinkoff/kora/example/controller/DataController.java`:

    ```java
    // ... existing imports ...
    import ru.tinkoff.kora.example.service.S3PresignedUrlService;

    @Component
    @HttpController
    public final class DataController {

        private final S3FileClient s3FileClient;
        private final S3PresignedUrlService presignedUrlService;

        public DataController(S3FileClient s3FileClient, S3PresignedUrlService presignedUrlService) {
            this.s3FileClient = s3FileClient;
            this.presignedUrlService = presignedUrlService;
        }

        // ... existing endpoints ...

        // Generate presigned download URL
        @HttpRoute(method = HttpMethod.GET, path = "/files/{fileId}/{filename}/download-url")
        @Json
        public PresignedUrlResponse getDownloadUrl(String fileId, String filename) {
            String url = presignedUrlService.generateDownloadUrl(fileId, filename, 60); // 1 hour expiry
            return new PresignedUrlResponse(url, 60);
        }

        // ... existing records ...

        @Json
        public record PresignedUrlResponse(String url, int expiresInMinutes) {}
    }
    ```

=== ":simple-kotlin: `Kotlin`"

    Update `src/main/kotlin/ru/tinkoff/kora/example/controller/DataController.kt`:

    ```kotlin
    // ... existing imports ...
    import ru.tinkoff.kora.example.service.S3PresignedUrlService

    @Component
    @HttpController
    class DataController(
        private val s3FileClient: S3FileClient,
        private val s3PresignedUrlService: S3PresignedUrlService
    ) {

        // ... existing endpoints ...

        // Generate presigned download URL
        @HttpRoute(method = HttpMethod.GET, path = "/files/{fileId}/{filename}/download-url")
        @Json
        fun getDownloadUrl(fileId: String, filename: String): PresignedUrlResponse {
            val url = s3PresignedUrlService.generateDownloadUrl(fileId, filename, 60) // 1 hour expiry
            return PresignedUrlResponse(url, 60)
        }

        // ... existing data classes ...
    }

    @Json
    data class PresignedUrlResponse(val url: String, val expiresInMinutes: Int)
    ```

### Testing Presigned Download URLs

Add tests for the presigned download URL functionality:

===! ":fontawesome-brands-java: `Java`"

    Update `src/test/java/ru/tinkoff/kora/example/S3FileClientTest.java`:

    ```java
    // ... existing imports ...
    import ru.tinkoff.kora.example.service.S3PresignedUrlService;

    @Testcontainers
    @KoraAppTest(TestApplication.class)
    public class S3FileClientTest {

        // ... existing test setup ...

        @TestComponent
        S3PresignedUrlService presignedUrlService;

        // ... existing tests ...

        @Test
        void shouldGenerateDownloadUrl() {
            // Given
            String fileId = UUID.randomUUID().toString();
            String filename = "test.txt";

            // When
            String downloadUrl = presignedUrlService.generateDownloadUrl(fileId, filename, 30);

            // Then
            assertThat(downloadUrl).isNotNull();
            assertThat(downloadUrl).contains("X-Amz-Expires=1800"); // 30 minutes
            assertThat(downloadUrl).contains("files/" + fileId + "/" + filename);
        }
    }
    ```

=== ":simple-kotlin: `Kotlin`"

    Update `src/test/kotlin/ru/tinkoff/kora/example/S3FileClientTest.kt`:

    ```kotlin
    // ... existing imports ...
    import ru.tinkoff.kora.example.service.S3PresignedUrlService

    @Testcontainers
    @KoraAppTest(TestApplication::class)
    class S3FileClientTest {

        // ... existing test setup ...

        @TestComponent
        lateinit var presignedUrlService: S3PresignedUrlService

        // ... existing tests ...

        @Test
        fun shouldGenerateDownloadUrl() {
            // Given
            val fileId = UUID.randomUUID().toString()
            val filename = "test.txt"

            // When
            val downloadUrl = presignedUrlService.generateDownloadUrl(fileId, filename, 30)

            // Then
            assertNotNull(downloadUrl)
            assertTrue(downloadUrl.contains("X-Amz-Expires=1800")) // 30 minutes
            assertTrue(downloadUrl.contains("files/$fileId/$filename"))
        }
    }
    ```

### Understanding When to Use Imperative vs Declarative

**Use Declarative Clients When:**
- Simple CRUD operations (upload, download, list, delete)
- Standard S3 object operations
- Type safety is more important than fine-grained control
- Operations follow predictable patterns

**Use Imperative Services When:**
- Presigned URLs and temporary access tokens
- Complex multipart uploads with custom logic
- Batch operations across multiple objects
- Custom metadata and tagging requirements
- Integration with third-party services
- Advanced security policies and access controls
- Operations requiring dynamic parameters or conditional logic

**Hybrid Approach:**
Many applications benefit from both approaches:
- Declarative clients for standard operations
- Imperative services for advanced features
- Clean separation of concerns in your architecture

This combination gives you the best of both worlds: type-safe, maintainable code for common operations, with the flexibility to handle complex requirements when needed.

## Key Concepts Learned

### S3-Compatible Storage
- **MinIO**: Local S3-compatible storage for development
- **Buckets**: Containers for organizing objects
- **Objects**: Files stored with unique keys
- **Metadata**: Additional information stored with files

### File Upload Patterns
- **Multipart Forms**: Handling file uploads in HTTP requests
- **Streaming**: Processing large files without loading into memory
- **Validation**: File type, size, and security checks
- **Unique Keys**: Preventing filename conflicts

### Imperative vs Declarative
- **Imperative**: Direct MinioClient usage for full control
- **Declarative**: Annotation-based clients for type safety
- **Trade-offs**: Flexibility vs convenience

### Error Handling
- **S3 Exceptions**: Handling storage-specific errors
- **Validation**: Input validation and security checks
- **Recovery**: Graceful error responses

## Next Steps

Continue your learning journey:

- **Next Guide**: [Observability & Monitoring](../observability.md) - Add metrics, tracing, and health checks
- **Related Documentation**:
  - [MinIO S3 Client](../../documentation/s3-client.md)
  - [HTTP Server](../../documentation/http-server.md)
  - [JSON Module](../../documentation/json.md)
- **Advanced Topics**:
  - [Presigned URLs](../../documentation/s3-client.md#presigned-urls)
  - [Batch Operations](../../documentation/s3-client.md#batch-operations)
  - [Custom Metadata](../../documentation/s3-client.md#metadata)

## Troubleshooting

### Connection Issues
- Ensure MinIO is running: `docker-compose ps`
- Check MinIO logs: `docker-compose logs minio`
- Verify configuration in `application.conf`

### Upload Failures
- Check file permissions and paths
- Verify bucket exists (should be auto-created)
- Check MinIO Console for error details

### Download Issues
- Verify file exists in MinIO Console
- Check file ID and filename in URL
- Ensure proper content type handling

### Performance Problems
- Large files may need streaming approach
- Check MinIO resource usage
- Consider multipart upload for large files